---
layout: distill
title: Graphs
description: Let‚Äôs break down how to make and use graphs ‚Äî the building blocks of networks.structure
tags: math
giscus_comments: true
date: 2025-01-24
thumbnail: assets/img/graph/graph.gif
bibliography: 

# Optionally, you can add a table of contents to your post.
# NOTES:
#   - make sure that TOC names match the actual section names
#     for hyperlinks within the post to work correctly.
#   - we may want to automate TOC generation in the future using
#     jekyll-toc plugin (https://github.com/toshimaru/jekyll-toc).
toc:
  - name: What is a Graph?
  - name: What does a Graph looks like?
  - name: How to create one?

# Below is an example of injecting additional post-specific styles.
# If you use this post as a template, delete this _styles block.
_styles: >
  .fake-img {
    background: #bbb;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 12px;
  }
  .fake-img p {
    font-family: monospace;
    color: white;
    text-align: left;
    margin: 12px 0;
    text-align: center;
    font-size: 16px;
  }
---

## What is a Graph?

A graph is a way to show how things (called nodes) are connected to each other through relationships (called edges). You can also store extra information about each node, edge, or even the whole graph to describe them better. Graphs are very flexible and can represent many kinds of real-world connections. Don‚Äôt worry if this sounds abstract ‚Äî we‚Äôll look at clear examples in the next section.

You‚Äôve probably seen graphs before in things like social networks. But graphs are much more powerful and can represent many kinds of data. For example, even images and text ‚Äî which might not seem like graphs at first ‚Äî can be modeled this way. By looking at them as graphs, we can discover patterns and structures that aren‚Äôt obvious, and build an intuition for understanding other, less regular types of graph data.
## What does a Graph looks like?

One cool way to see how a graph‚Äôs nodes are connected is with something called an adjacency matrix. Here, we‚Äôve taken a tiny 4√ó4 image (just 16 pixels) and shown how the nodes (pixels) link up in a grid. Each cell in the matrix tells you if two nodes are connected. The three views below ‚Äî the grid, the matrix, and the graph ‚Äî are just different ways of looking at the same data.
<div class="container">
    <div class="panel">
        <div>Image Pixels</div>
        <svg id="grid"></svg>
    </div>
    <div class="panel">
        <div>Adjacency Matrix</div>
        <svg id="matrix"></svg>
    </div>
    <div class="panel">
        <div>Graph</div>
        <svg id="graph"></svg>
    </div>
</div>
<!-- Load D3.js from CDN -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<!-- Load your custom CSS -->
<link rel="stylesheet" href="{{ '/assets/css/graph/styles.css | relative_url '}}">

<!-- Load your custom JS -->
<script src="{{ '/assets/js/graph/script.js | relative_url '}}"></script>

---

## How to create a graph data structure?

Okay, let‚Äôs get hands-on. Building a graph isn‚Äôt scary ‚Äî it‚Äôs just about figuring out how to store nodes (the ‚Äúdots‚Äù) and edges (the ‚Äúlines‚Äù connecting them).

We‚Äôll walk through this step by step:

### Storing Nodes

In most cases, we don‚Äôt need a fancy structure for nodes. You can just store them in a list or set. For example:

<d-code block language="javascript">
    # Let's define our nodes
    nodes = ["A", "B", "C", "D"]
    print("Nodes:", nodes)
</d-code>

### Representing Connections (Adjacency Matrix)

Once you‚Äôve got nodes, you need to show which ones are connected.

An adjacency matrix is like a big grid. Each row and column represents a node. If two nodes are connected, we put 1; otherwise, 0.

<d-code block language="javascript">
    # Create adjacency matrix for 4 nodes
    # A -- B
    # |    |
    # C -- D
    adj_matrix = [
        [0, 1, 1, 0],  # Connections for A
        [1, 0, 0, 1],  # Connections for B
        [1, 0, 0, 1],  # Connections for C
        [0, 1, 1, 0],  # Connections for D
    ]
</d-code>
This matrix says:

**Connections:**
- A ‚Üí B, C
- B ‚Üí A, D
- C ‚Üí A, D
- D ‚Üí B, C

### Traversing the Graph (Visiting Nodes)
Now let‚Äôs say you want to walk through your graph ‚Äî maybe to find all nodes or paths. Two popular ways are:

### üï∏Ô∏è Depth-First Search (DFS)
Think of it like exploring as far as possible down one path before backtracking.
<d-code block language="javascript">
    def dfs(node, visited):
        if node not in visited:
            print("Visiting:", node)
            visited.add(node)
            for neighbor, connected in enumerate(adj_matrix[node]):
                if connected:
                    dfs(neighbor, visited)

    visited = set()
    dfs(0, visited)  # Start at node 0 (A)
</d-code>
### üåä Breadth-First Search (BFS)
This one explores level by level ‚Äî like ripples in water.

<d-code block language="javascript">
    def bfs(start):
        visited = set()
        queue = deque([start])

        while queue:
            node = queue.popleft()
            if node not in visited:
                print("Visiting:", node)
                visited.add(node)
                for neighbor, connected in enumerate(adj_matrix[node]):
                    if connected and neighbor not in visited:
                        queue.append(neighbor)

    bfs(0)  # Start at node 0 (A)
</d-code>
With this basic setup, you can start doing cool stuff like finding paths, checking if your graph is connected, or even visualizing it.

